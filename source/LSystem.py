from dataclasses import dataclass
from typing import List, Callable, Any
import numpy as np
import random
import copy
import json

@dataclass
class SymbolType:
    name: str
    dimension: int
    paramGenerator: Callable[[int], float] #returns a parameter to place at the passed index if this SymbolType is generated by a mutation

@dataclass
class Symbol:
    type: SymbolType
    params: List[float] 

    def apply(self): #only for symbols that are Production
        return self.type.apply(self)
    
    def generateParams(self):
        self.params = [self.type.paramGenerator(i) for i in range(self.type.dimension)]

def defaultParamGenerator(paramIndex):
    return 0.0

def randomMatrixElementGenerator():
    return np.random.normal(loc=0, scale=10)

def FParamGenerator(paramIndex):
    # mpm.py should divide these by 100 and maybe clip them
    if paramIndex == 0: return 2 #np.random.normal(1, 0.25)
    elif paramIndex == 1: return 1 #np.random.normal(0.25,0.05)

    elif paramIndex == 2: return np.random.normal(1,1)
    elif paramIndex == 3: return np.random.normal(5,2)
    elif paramIndex == 4: return np.random.normal(0, np.pi/2)

def GParamGenerator(paramIndex):
    # mpm.py should divide these by 100 and maybe clip them
    if paramIndex == 0: return 2 #np.random.normal(1, 0.25)
    elif paramIndex == 1: return 1 #np.random.normal(0.25,0.05)

def turnParamGenerator(paramIndex):
    if paramIndex == 0: return np.random.normal(np.pi/2, 2*np.pi/3)

def repeatParamGenerator(paramIndex):
    if paramIndex == 0: return 1

def productionParamGenerator(paramIndex):
    return randomMatrixElementGenerator()

F = SymbolType("F", 5, FParamGenerator)
G = SymbolType("G", 2, GParamGenerator)
left = SymbolType("-", 1,turnParamGenerator)
right = SymbolType("+", 1, turnParamGenerator)

defaultCommands = [F, G, left, right]
boostCommands = [F, G, left, right]
repeatLeft = SymbolType("{", 0, defaultParamGenerator)
repeatRight = SymbolType("}", 1, repeatParamGenerator)
push = SymbolType("[", 0, defaultParamGenerator)
pop = SymbolType("]", 0, defaultParamGenerator)
defaultControls = [repeatLeft, repeatRight, push, pop]

@dataclass
class ProductionType(SymbolType): #could have ProductionTypes that are more general than this
    matrix: np.ndarray 
    pattern: List[SymbolType]

    def apply(self, input: Symbol) -> List[Symbol]:
        vecIn = np.array(input.params).reshape(2, 1)
        oneRow = np.array([[1]])
        vecIn = np.vstack((vecIn, oneRow))

        vecOut = self.matrix @ vecIn
        vecOut = vecOut.flatten()

        result = []
        index = 0
        for patternSymbolType in self.pattern:
            params = vecOut[index:index+patternSymbolType.dimension].tolist()
            if len(params) != patternSymbolType.dimension: print("BAD")
            result.append(Symbol(patternSymbolType, params))
            index += patternSymbolType.dimension
        
        return result
    
    def deleteSymbolAtIndex(self, index, bypass=False):
        if (self.pattern[index].name == "[" or self.pattern[index].name == "]") and not bypass: 
            self.deleteSymbolPair(index, "[", "]")

        elif (self.pattern[index].name == "{" or self.pattern[index].name == "}") and not bypass: 
            self.deleteSymbolPair(index, "{", "}")

        else:
            rowsBefore = 0
            for i in range(index):
                rowsBefore += self.pattern[i].dimension
            self.matrix = np.delete(self.matrix, range(rowsBefore, rowsBefore+self.pattern[index].dimension), axis=0)

            del self.pattern[index]

    def deleteSymbolPair(self, index, leftName, rightName):
        if self.pattern[index].name == leftName:
            counter = 1
            for i in range(index+1, len(self.pattern)):
                if self.pattern[i].name == leftName: counter += 1
                if self.pattern[i].name == rightName: counter -= 1
                if counter == 0:
                    self.deleteSymbolAtIndex(i, bypass=True)
                    self.deleteSymbolAtIndex(index, bypass=True)
                    break

        elif self.pattern[index].name == rightName:
            counter = 1
            for i in reversed(range(0, index)):
                if self.pattern[i].name == leftName: counter -= 1
                if self.pattern[i].name == rightName: counter += 1
                if counter == 0:
                    self.deleteSymbolAtIndex(index, bypass=True)
                    self.deleteSymbolAtIndex(i, bypass=True)
                    break
                
    def addSymbolAtIndex(self, index, symbolType, bypass=False):
        index = min(index, len(self.pattern))
        if (symbolType.name == "{" or symbolType.name == "[") and not bypass:
            closeIndex = np.random.randint(index, len(self.pattern)+1)
            if symbolType.name == "{":
                self.addSymbolAtIndex(closeIndex, repeatRight, bypass=True)
                self.addSymbolAtIndex(index, repeatLeft, bypass=True)
            elif symbolType.name == "[":
                self.addSymbolAtIndex(closeIndex, pop, bypass=True)
                self.addSymbolAtIndex(index, push, bypass=True)

        elif (symbolType.name == "}" or symbolType.name == "]") and not bypass:
            closeIndex = np.random.randint(0, index) if index != 0 else 0
            if symbolType.name == "}":
                self.addSymbolAtIndex(index, repeatRight, bypass=True)
                self.addSymbolAtIndex(closeIndex, repeatLeft, bypass=True)
            elif symbolType.name == "]":
                self.addSymbolAtIndex(index, pop, bypass=True)
                self.addSymbolAtIndex(closeIndex, push, bypass=True)

        else:                           
            self.pattern.insert(index, symbolType)
            params = [symbolType.paramGenerator(i) for i in range(symbolType.dimension)]
            newRows = np.zeros((len(params), self.dimension+1))
            newRows[:,-1] = params
            rowsBefore = 0
            for i in range(index):
                rowsBefore += self.pattern[i].dimension

            if self.matrix is None:
                self.matrix = newRows
            else:
                self.matrix = np.vstack((self.matrix[:rowsBefore], newRows, self.matrix[rowsBefore:]))

class LSystem:
    def __init__(self, axiom: List[Symbol], productions: List[ProductionType]):
        self.axiom = axiom 
        self.productions = productions
        self.iterations = 1
        self.ancestor = None

    def clone(self):
        new_system = LSystem([], [])
        new_system.axiom = [copy.deepcopy(symbol) for symbol in self.axiom]
        new_system.productions = [copy.deepcopy(prod) for prod in self.productions]
        new_system.iterations = self.iterations
        return new_system

    def getIteration(self):
        currentSequence = self.axiom
        for _ in range(self.iterations):
            newSequence = []
            for symbol in currentSequence:
                if isinstance(symbol.type, ProductionType):
                    newSequence.extend(symbol.apply())
                else:
                    newSequence.append(symbol)
            
            currentSequence = newSequence
  
        return currentSequence

    def generateBlock(self, minLength=3, maxLength=8, allowRepeats=True, allowPushPop=True):
        block = []
        blockLength = random.randint(minLength,maxLength)
        isRepeated = random.choice([True, False])
        isPushPop = random.choice([True, False])

        blockSelections = defaultCommands + self.productions + boostCommands
        for _ in range(blockLength):
            newSymbol = Symbol(random.choice(blockSelections), [])
            block.append(newSymbol)
        
        if isRepeated and allowRepeats:
            block.insert(0, Symbol(repeatLeft, []))
            block.append(Symbol(repeatRight, [random.randint(1,5)]))
        
        if isPushPop and allowPushPop:
            block.insert(0, Symbol(push, []))
            block.append(Symbol(pop, []))

        for symbol in block: symbol.generateParams()

        return block
    
    def mutate(self):
        # We will mutate a single production rule by either changing its pattern or one of the elements in its matrix
        production = random.choice(self.productions)

        if random.random() < 0.9: # Change the production rule's pattern by swapping one symbol for another
            if len(production.pattern) == 0:
                return
            index = random.randrange(len(production.pattern)) 
            newSymbol = random.choice(defaultCommands+defaultControls+self.productions+boostCommands)
            production.deleteSymbolAtIndex(index)
            production.addSymbolAtIndex(index, newSymbol)

        if random.random() < 0.9: # Change the production rule's pattern by deleting one symbol
            if len(production.pattern) == 0:
                return
            index = random.randrange(len(production.pattern)) 
            production.deleteSymbolAtIndex(index)
        
        if random.random() < 0.9: # Change the production rule's pattern by adding one symbol
            index = random.randrange(len(production.pattern)) if len(production.pattern) > 0 else 0
            newSymbol = random.choice(defaultCommands+defaultControls+self.productions+boostCommands)
            production.addSymbolAtIndex(index, newSymbol)

        if random.random() < 1: # Change the value of some of the matrix elements
            rows, _ = production.matrix.shape
            if rows == 0:
                return
            scale = np.where(production.matrix == 0, 1, np.abs(production.matrix) * 5)
            noise = np.random.normal(loc=0.0, scale=scale, size=production.matrix.shape)
            production.matrix = production.matrix+noise

        if random.random() < 0.9: # Mutate parameters in the axiom
            for symbol in self.axiom:
                for index, parameter in enumerate(symbol.params):
                    scale = np.abs(parameter)*0.5
                    noise = np.random.normal(loc=0, scale=scale)
                    symbol.params[index] += noise

            symbol = random.choice(self.axiom)
            if symbol.type.dimension !=0:
                parameterIndex = np.random.randint(0, symbol.type.dimension)
                currentParam = symbol.params[parameterIndex] 

        if random.random() < 0.9: # Increment or decrement the number of iterations, with minimum 1
            self.iterations += random.choice([-1,1])
            if self.iterations < 1: self.iterations = 1

        if random.random() < 0.5:
            newSymbolType = random.choice(defaultCommands+self.productions+boostCommands)
            index = random.randrange(len(self.axiom)) 
            newSymbol = Symbol(newSymbolType, [])
            newSymbol.generateParams()
            self.axiom.insert(index, newSymbol)

    def generateProductions(self, nProductions, nParameters, paramGenerator):
        for i in range(nProductions):
            pattern = [symbol.type for symbol in self.generateBlock()]
            insertion = random.choice(range(len(pattern)))
            name = "P" + str(i)
            newProduction = ProductionType(name=name, dimension=nParameters, paramGenerator=paramGenerator, matrix=None, pattern=[])
            for index, symbolType in enumerate(pattern):
                newProduction.addSymbolAtIndex(index, symbolType)
            newProduction.addSymbolAtIndex(insertion, newProduction) # enforce that productions should refer to themselves, at least to start
            self.productions.append(newProduction)

    def seed(self):
        self.iterations = np.random.randint(1,6)
        self.generateProductions(3, 2, productionParamGenerator)
        baseActuator = Symbol(F, []) # make every structure have at least one actuator 
        baseActuator.generateParams()
        self.axiom = [baseActuator]+self.generateBlock()

        # seed at least one production in the axiom to avoid structures that don't iterate
        insertion = random.choice(range(len(self.axiom)))
        productionType = random.choice(self.productions)
        newSymbol = Symbol(productionType, [])
        newSymbol.generateParams()
        self.axiom.insert(insertion, newSymbol)

    def print(self):
        print(f"Ancestor: {self.ancestor}")
        print(f"Iterations: {self.iterations}")
        print(f"Axiom: {axiomString(self.axiom)}")
        printAxiom(self.axiom)
        print(f"Iterated axiom: {axiomString(self.getIteration())}")
        for production in self.productions:
            printProduction(production)

def printAxiom(system):
    for symbol in system:
        print(f"Symbol: {symbol.type.name}, Parameters: {symbol.params}")

def axiomString(axiom):
    output = ""
    for symbol in axiom:
        output += symbol.type.name
    return output

def patternString(pattern):
    output = ""
    for symbolType in pattern:
        output += symbolType.name
    return output

def printProduction(production):
    print(f"Production: {production.name}, Pattern: {patternString(production.pattern)}")
    print("Matrix: ")
    print(production.matrix)

